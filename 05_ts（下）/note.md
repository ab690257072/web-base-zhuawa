## 面试题

### 1. 类型推论 & 可赋值性

#### 什么是类型推论？
没主动指定类型时，ts会推断并标注类型

#### 以下代码ts推论的类型是什么？
``` javascript
let a = 1024; // a: number = 1024
let b = '1024'; // b: string = '1024'
const c = 'apple'; // c: 'apple'
let d = [true, false, true]; // d: boolean[]
const dd = [true, false]; // dd: boolean[]
let e = { name: 'apple' }; // e: { name: string }
let f = null; // f: any = null
```

可以看到，c是由const声明的，它的类型会被收缩为1个具体值，含义是无法赋值为其他同类型值；对象因为没法表示为具体值，所以const和let声明效果是一样的，比如dd；
f推论是any，原因是类型拓宽，因为用户没具体指定什么类型，所以找1个最近的能涵盖该类型的宽类型来指定。

类型涵盖关系如下，顶上的包含下面的（上方类型更宽）：
![](https://raw.githubusercontent.com/ab690257072/Picture/master/img/20220608183837.png)

##### tip：
- never是程序未正常执行下去，表示没法获取或猜测类型，比如将变量写成死循环函数，则其推论类型是never；
- tsconfig 中配置不同的话，推论类型可能受影响而不同。

#### 可赋值性是什么？
A类型是否能被赋值给B类型：
1. A是B的子类型（A范围小，能赋值给B）
2. A是any类型（与1刚好相反，any是作为范围大的可以赋值给范围小的）

具体例子：
![](https://raw.githubusercontent.com/ab690257072/Picture/master/img/20220608190556.png)
![](https://raw.githubusercontent.com/ab690257072/Picture/master/img/20220608190648.png)

> 第2点需要试验下

### 2. 类型断言
用户强制明确变量的类型，告诉编译器不需要去推论或校验；
写法有`<>`，`as` 两种；
问题是可能会有潜在错误，因为断言的类型可能不准确，但ts不会校验

### 3. type 和 interface 的异同
type侧重类型，interface侧重结构（也就是说，interface语义更强）
- 相同点：都可以描述某个对象或函数
- 不同点：
	- 语法不同
	- interface若重复定义，则会自动合并，而type需要主动合并

### 4. 装饰器问题
#### 分类
类装饰器
方法装饰器
访问器装饰器（get、set）
方法参数装饰器
属性装饰器

#### 执行顺序
- 有多个参数装饰器时，从最后一个参数往前执行
- 方法参数在方法装饰器之前执行
- 类装饰器总是最后执行
- 方法和属性装饰器谁在前谁先执行，参数装饰器紧挨着方法装饰器执行（因为就是方法的一部分）

#### 类装饰器的执行时机
在编译前就已经执行了，相当于立即执行 IIFE，也就是说，编译完后就是强化后的新类，而非运行时才强化。

### 5. 接口类型
属性类接口
函数类接口
可索引接口
类类型接口
扩展接口